포인터:주소를 가지고 있는 변수를 말한다.


변수는 메모리에 저장된다.
메모리는 바이트 단위로 접근한다.
예를 들어)
    처음 주소는 0바이트 그다음은 1바이트..~

전에 변수를 설명할 때 각 자료형에 해당하는 바이트 크기가 존재한다고 했다.

char부터 1byte
short 2
int 4
long 4
long long 8

float 4
double 8

그림을 본다면
int는 4칸을 차지하며 10이라는 값이 저장되는 것이다.

그럼 이런 변수들의 주소는 어떻게 알 수 있을까?

전에 한 번 언급한 적이 있다.

&(andpercent)기호이다.
이 기호를 변수 앞에 붙여주면 &변수를 합쳐서 변수의 주소라고 한다.


포인터의 문법은 
자료형 *변수이름; 이런 식으로 설정한다.

포인터 변수도 변수의 일종이므로 변수를 만들면 메모리 상에서 자료형 만큼 차지하게 된다.

그럼 포인터는 주소를 갖는다고 했는데 그랬을 때 어떻게 되는 것인지는 다음 예문을 보자.

int j=10;
int *p=&j;
이런 식으로 사용이 가능하다.

p라는 변수는 포인터 변수로 주소를 갖는 변수이다.
그리고 j는 int 자료형의 변수이고 10이라는 값을 저장하고 있는 변수이다.

메모리상에서 그림을 그려보자면

이런식으로 될 것이다.

전에 변수 파트를 배울 때 변수를 초기화하지 않고 사용하는 것은 매우 위험한 행동이라는 것을 알고 있을 것입니다.

왜냐면 변수는 선언되었을 때 메모리상에서 자료형의 크기만큼 자리를 차지하게 되고 그곳에 원래 있던 값을 받게 됩니다.

즉 쓰레기값이죠 그 값이 무엇인줄 알고 값을 바꿉니까? 자칫하면 큰일이 날 수 있기에 그런 행동을 해서는 안됩니다.

포인터 같은 경우도
int*p;
이런식으로 선언만 할 수 있는데요.

선언만 했을 때는 포인터는 주소를 갖는 변수이기에 아무런 주소를 갖고 있지 않는 상태입니다.

이럴 때 맘대로 접근하다가는 거부 명령이 뜨면서 에러가 발생합니다.
그렇기에 포인터도 처음에 선언을 하고 웬만해서는 바로 주소를 넣어줘서 값을 주는 것이 좋습니다.

하지만 딱히 바로 넣을 수 있는 값이 없다. 하면 넣을 수 있는 것이
아무것도 가리키지 않는다는 의미에서 NULL 이라는 값을 넣어줄 수 있습니다.

하지만 이때도 아무런 값을 넣지 않았을 뿐이지 접근을 자유자재로 해도 된다는 것은 아닙니다.

포인터 변수는 주소 값을 정상적으로 주었을 때만 접근할 수 있다고 기억해두시면 좋을 것 같습니다.

그럼 이런 포인터 변수는 주소를 갖는데 주소를 가져서 무슨 소용이냐?
라는 질문을 할 수 있을 것 같습니다. 포인터 변수는 주소를 갖는 것이지만 

자신이 갖고 있는 주소에 접근해서 값을 자유자재로 변환할 수 있는 큰 강점이 있습니다.

주소에 접근하는 방법은 
선언했을 때와 동일하게
*p 이런식으로 써주시면 자신이 갖고 있는 주소에 접근하겠다 라는 의미입니다.
그래서 변수에 다른 값을 저장한다는 느낌으로
*p = 10;
이런식으로 써도 상관없습니다. 이러면 p가 10으로 바뀌는 것이 아닌 p가 가리키고 있는 변수에 저장된 값이 10으로 바뀌는 것입니다.


그럼 주소에 접근을 할 때 포인터는 어떤 식으로 접근하냐면 자신이 갖고 있는 주소부터 시작해서 자신의 자료형 만큼을
바이트 단위로 읽습니다. 그럼 char ,double, int 마다 각각 읽는 범위가 다르기 때문에 변수가 저장됐을 때 다른 자료형으로 읽는다면

예기치 못한 일이 벌어질 수도 있습니다. 그렇기 때문에 자신이 접근하려는 주소의 자료형과 포인터의 자료형을 같게 해주셔야 합니다.

다음으로는 포인터의 연산에 대해서 보겠습니다.
포인터 같은 경우 연산이 가능한데요. 증가, 감소, 덧셈, 뺄셈 연산이 가능합니다. 
증가같은 경우 자신이 가리키고 있는 주소의 바이트값이 자신의 자료형 만큼 증가된다고 생각하시면 됩니다.

이게 무슨 말이냐면 
int *p = 8;
이런식이었다면 p에는 8이라는 주소값이 들어가 있으므로 
p++; 이렇게 기술하였을 떄 p가 가리키고 있는 주소의 값은 12byte가 될 것 입니다.

또한 덧셈 뺄셈도 마찬가지 입니다. 1을 더하면 주소가 1 커지거나 작아지는 것이므로 자신의 포인터 자료형만큼 주소가 커지거나 줄어들 것입니다.

double 같은 경우 8씩 커지거나 작아지겠죠
char는 1씩 커지거나 작아지구요

그러면 다음 수식을 모두 한 번 해석해봅시다.
v = *p++;
v = (*p)++;
v = *++p;
v = ++*p;

포인터도 필요한 경우 명시적으로 포인터의 타입을 변경할 수 있다!(int *) 이런식으로

함수는 호출 시에는 인수를 전달하게 된다.
add(1,3);//저번의  add함수를 예시로 들면

call by value < 변수의 값이 복사되어 넘어간다.

call by reference < 함수의 주소가 넘어간다.


포인터와 배열

배열 이름이 포인터이다.

포인터를 그래서 배열 처럼 사용이 가능하다.


배열의 첫번째가 주소라는 것을 예전에 했을 것이다.

배열을 그래서 포인터처럼 사용이 가능하다.

예를들어 이런 식이다
*(a+1) ==> a[1] 이다.

그럼 배열을 함수의 매개변수로 넣으면 어떻게 될까? 당연히 call by reference 일 것이다.

int b[] , int *b 는 동일한 것이다.


포인터를 사용하면 장점이 인덱스 표기법 보다 빠르다.

왜냐하면 인덱스를 주소로 변환할 필요가 없기 때문이다.

*p++; a[i];


포인터를 배웠으면 함수의 반환값을 포인터로도 쓸 수 있다.

하지만 조심해야 하는 것이 함수는 종료되면 변수가 메모리 상에서 해제되기 때문에 오류가 생길 수 있다!