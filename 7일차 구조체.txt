자료형
1.기초 자료형
2.파생 자료형
3.사용자정의 자료형

구조체가 나오게 된 이유:
    학생에 대한 데이터를 하나로 묶을 수는 없을까?
    예를 들어) 학교에 다니는 홍길동이라는 아이에 대한 데이터를 저장한다고 생각을 해보자.
    그러면 일단 학번, 이름, 학점, 전화번호 등등이 필요하다.
    그런데 학번, 이름, 학점 같은 경우는 다 다른 자료형의 데이터이다.
    학번은 정수형 데이터, 혹은 문자형 데이터이다.
    이름은 문자형 데이터 일 것이다.
    그리고 마지막으로 학점 같은 경우 실수형 데이터일 것이다.
우리는 이전까지 같은 자료형을 하나로 묶은 것은 보았었다.

그것이 무엇이었나? (배열)

이런 이유로 구조체가 나오게 되었다.

구조체는
struct 이름{
    자료형 자료의 이름;
    자료형 자료의 이름;
};

이런식으로 기술하게 된다.

구조체를 저런식으로 만들었다는 것은 변수를 만들었다는 것이 아니다!

구조체 변수를 한 번 선언해보자.

struct 이름 변수이름; 이런식으로 기술하면 되고

초기화같은 경우 중괄호를 이용해서 초기값을 나열하면 된다.

그럼 만들 변수에서 구조체에 멤버에 접근하기 위해서는

. 연산자를 이용하면 된다.


같은 구조체 변수끼리 대입은 가능하지만 비교는 불가능하다.
구조체는 구조체를 멤버로 가질 수 있다!


구조체 변수 또한 가능!


구조체와 포인터

구조체 포인터는 -> 연산자를 이용해서 멤버변수에 접근할 수 있다.



그러면 구조체 멤버변수에 구조체 포인터 변수를 갖는다면?
접근하려면 -> 연산자를 이용해야 할 것이다!



구조체와 함수관계

구조체의 복사본이 함수로 전달되게 된다.
만약 구조체의 크기가 크면 그만큼 시간과 메모리가 소요된다.

그렇기에 구조체는 포인터로 인자를 넘겨주어 시간과, 공간을 절약할 수 있다.

또한 반환 자료형으로 구조체를 줄 수 있는데 이랬을 경우 복사본이 반환된다.


typedef은 원래 있던 자료형을 새로운 자료형으로 이름을 붙여주는 것이다.
구조체 같은 경우 typedef를 써서 같이 많이 쓰게 된다.


typedef 와 #define을 비교
이식성을 높여준다.
typedef float aa[5];
이런식으로 새로운 배열을 정의해줄 수도 있다.
